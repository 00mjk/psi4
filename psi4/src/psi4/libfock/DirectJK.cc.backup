/*
 * @BEGIN LICENSE
 *
 * Psi4: an open-source quantum chemistry software package
 *
 * Copyright (c) 2007-2019 The Psi4 Developers.
 *
 * The copyrights for code used from other parties are included in
 * the corresponding files.
 *
 * This file is part of Psi4.
 *
 * Psi4 is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * Psi4 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with Psi4; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * @END LICENSE
 */

#include "psi4/lib3index/3index.h"
#include "psi4/libpsio/psio.hpp"
#include "psi4/libpsio/psio.h"
#include "psi4/libpsio/aiohandler.h"
#include "psi4/libqt/qt.h"
#include "psi4/psi4-dec.h"
#include "psi4/psifiles.h"
#include "psi4/libmints/sieve.h"
#include "psi4/libiwl/iwl.hpp"
#include "jk.h"
//#include "jk_independent.h"
//#include "link.h"
//#include "direct_screening.h"
//#include "cubature.h"
//#include "points.h"
#include "psi4/libmints/matrix.h"
#include "psi4/libmints/basisset.h"
#include "psi4/libmints/molecule.h"
#include "psi4/libmints/twobody.h"
#include "psi4/libmints/integral.h"
#include "psi4/lib3index/cholesky.h"
#include "psi4/libpsi4util/process.h"
#include "psi4/liboptions/liboptions.h"

#include <algorithm>
#include <limits>
#include <sstream>
#include <set>
#include "psi4/libpsi4util/PsiOutStream.h"
#ifdef _OPENMP
#include <omp.h>
#include "psi4/libpsi4util/process.h"
#endif

using namespace psi;

namespace psi {
DirectJK::DirectJK(std::shared_ptr<BasisSet> primary) : JK(primary) { common_init(); }
DirectJK::~DirectJK() {}
void DirectJK::common_init() {
    df_ints_num_threads_ = 1;
#ifdef _OPENMP
    df_ints_num_threads_ = Process::environment.get_n_threads();
#endif
}
size_t DirectJK::memory_estimate() {
    return 0;  // Effectively
}
void DirectJK::print_header() const {
    if (print_) {
        outfile->Printf("  ==> DirectJK: Integral-Direct J/K Matrices <==\n\n");

        outfile->Printf("    J tasked:          %11s\n", (do_J_ ? "Yes" : "No"));
        outfile->Printf("    K tasked:          %11s\n", (do_K_ ? "Yes" : "No"));
        outfile->Printf("    wK tasked:         %11s\n", (do_wK_ ? "Yes" : "No"));
        if (do_wK_) outfile->Printf("    Omega:             %11.3E\n", omega_);
        outfile->Printf("    Integrals threads: %11d\n", df_ints_num_threads_);
        // outfile->Printf( "    Memory [MiB]:      %11ld\n", (memory_ *8L) / (1024L * 1024L));
        outfile->Printf("    Schwarz Cutoff:    %11.0E\n\n", cutoff_);
    }
}
void DirectJK::preiterations() { /* sieve_ = std::make_shared<ERISieve>(primary_, cutoff_, do_csam_);*/
}
void DirectJK::compute_JK() {
    auto factory = std::make_shared<IntegralFactory>(primary_, primary_, primary_, primary_);

    if (do_wK_) {
        std::vector<std::shared_ptr<TwoBodyAOInt>> ints;
        for (int thread = 0; thread < df_ints_num_threads_; thread++) {
            ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->erf_eri(omega_)));
        }
        // TODO: Fast K algorithm
        if (do_J_) {
            build_JK(ints, D_ao_, J_ao_, wK_ao_);
        } else {
            std::vector<std::shared_ptr<Matrix>> temp;
            for (size_t i = 0; i < D_ao_.size(); i++) {
                temp.push_back(std::make_shared<Matrix>("temp", primary_->nbf(), primary_->nbf()));
            }
            build_JK(ints, D_ao_, temp, wK_ao_);
        }
    }

    if (do_J_ || do_K_) {
        std::vector<std::shared_ptr<TwoBodyAOInt>> ints;
        ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));
        for (int thread = 1; thread < df_ints_num_threads_; thread++) {
            ints.push_back(std::shared_ptr<TwoBodyAOInt>(ints[0]->clone()));
        }
        if (do_J_ && do_K_) {
            build_JK(ints, D_ao_, J_ao_, K_ao_);
        } else if (do_J_) {
            std::vector<std::shared_ptr<Matrix>> temp;
            for (size_t i = 0; i < D_ao_.size(); i++) {
                temp.push_back(std::make_shared<Matrix>("temp", primary_->nbf(), primary_->nbf()));
            }
            build_JK(ints, D_ao_, J_ao_, temp);
        } else {
            std::vector<std::shared_ptr<Matrix>> temp;
            for (size_t i = 0; i < D_ao_.size(); i++) {
                temp.push_back(std::make_shared<Matrix>("temp", primary_->nbf(), primary_->nbf()));
            }
            build_JK(ints, D_ao_, temp, K_ao_);
        }
    }
}
void DirectJK::postiterations() { /*sieve_.reset();*/
}
void DirectJK::build_JK(std::vector<std::shared_ptr<TwoBodyAOInt>>& ints, std::vector<std::shared_ptr<Matrix>>& D,
                        std::vector<std::shared_ptr<Matrix>>& J, std::vector<std::shared_ptr<Matrix>>& K) {
    // => Zeroing <= //
    for (size_t ind = 0; ind < J.size(); ind++) {
        J[ind]->zero();
    }
    for (size_t ind = 0; ind < K.size(); ind++) {
        K[ind]->zero();
    }

    int nthread = df_ints_num_threads_;

    // get function pair blocking info from the integral engine
    auto blocksPQ = ints[0]->get_blocks12();
    auto blocksRS = ints[0]->get_blocks34();
    auto blocksize = ints[0]->maximum_block_size();
    bool use_batching = blocksize > 1;

    // => Find the groups of PQ/RS blocks that have the same atoms involved <= //
    std::vector<int> PQtask_offsets;
    int current_atom_p = -1;
    int current_atom_q = -1;
    for (size_t blockPQ_idx = 0; blockPQ_idx < blocksPQ.size(); blockPQ_idx++) {
        int atom_p = primary_->shell(blocksPQ[blockPQ_idx][0].first).ncenter();
        int atom_q = primary_->shell(blocksPQ[blockPQ_idx][0].second).ncenter();
        if (current_atom_p != atom_p || current_atom_q != atom_q) {
            PQtask_offsets.push_back(blockPQ_idx);
            current_atom_p = atom_p;
            current_atom_q = atom_q;
        }
    }
    PQtask_offsets.push_back(blocksPQ.size());
    std::vector<int> RStask_offsets;
    if (use_batching) {
        int current_atom_r = -1;
        int current_atom_s = -1;
        for (size_t blockRS_idx = 0; blockRS_idx < blocksRS.size(); blockRS_idx++) {
            int atom_r = primary_->shell(blocksRS[blockRS_idx][0].first).ncenter();
            int atom_s = primary_->shell(blocksRS[blockRS_idx][0].second).ncenter();
            if (current_atom_r != atom_r || current_atom_s != atom_s) {
                RStask_offsets.push_back(blockRS_idx);
                current_atom_r = atom_r;
                current_atom_s = atom_s;
            }
        }
        RStask_offsets.push_back(blocksRS.size());
    } else {
        RStask_offsets = PQtask_offsets;
    }
    int count = 0;
    for(const auto o: RStask_offsets) std::cout << count++ << " offset " << o << std::endl; 
    exit(1);
    // => The maximum amount of storage associated with any atom =< //
    std::vector<int> nfunctions(primary_->molecule()->natom(), 0);
    for (int shellnum = 0; shellnum < primary_->nshell(); ++shellnum) {
        const auto& shell = primary_->shell(shellnum);
        nfunctions[shell.ncenter()] += shell.nfunction();
    }
    for (const auto &s : nfunctions) std::cout << "GREPSIZE " << s << std::endl;
    size_t max_task = *std::max_element(nfunctions.begin(), nfunctions.end());

    // => Intermediate Buffers <= //

    std::vector<std::vector<std::shared_ptr<Matrix>>> JKT;
    for (int thread = 0; thread < nthread; thread++) {
        std::vector<std::shared_ptr<Matrix>> JK2;
        for (size_t ind = 0; ind < D.size(); ind++) {
            JK2.push_back(std::make_shared<Matrix>("JKT", (lr_symmetric_ ? 6 : 10) * max_task, max_task));
        }
        JKT.push_back(JK2);
    }

    size_t computed_shells = 0L;
    size_t numPQtasks = PQtask_offsets.size() - 1;
    size_t numRStasks = RStask_offsets.size() - 1;
    size_t numPQRStasks = numPQtasks * numRStasks;
//#pragma omp parallel for schedule(dynamic) num_threads(nthread)
    for (size_t PQRStask = 0; PQRStask < numPQRStasks; ++PQRStask) {
//#ifdef _OPENMP
//        const int rank = omp_get_thread_num();
//#else
        const int rank = 0;
//#endif
        size_t PQtask = PQRStask / numRStasks;
        size_t RStask = PQRStask % numRStasks;
        const auto& buffers = ints[rank]->buffers();
        // size_t start = ints[rank]->first_RS_shell_block(blockPQ_idx);
        bool touched = false;
        const auto& firstPQ = blocksPQ[PQtask_offsets[PQtask]][0];
        const auto& firstRS = blocksRS[RStask_offsets[RStask]][0];
        int firstP = std::numeric_limits<int>::max();
        int firstQ = std::numeric_limits<int>::max();
        int firstR = std::numeric_limits<int>::max();
        int firstS = std::numeric_limits<int>::max();
        // Quickly loop through the task list and find the first shell for each index; they
        // may not necessarily be sorted in ascending order
        for (size_t blockPQ_idx = PQtask_offsets[PQtask]; blockPQ_idx < PQtask_offsets[PQtask + 1]; blockPQ_idx++) {
            const auto& blockPQ = blocksPQ[blockPQ_idx];
            for (const auto& pairPQ : blockPQ) {
                firstP = std::min(firstP, pairPQ.first);
                firstQ = std::min(firstQ, pairPQ.second);
            }
        }
        for (size_t blockRS_idx = RStask_offsets[RStask]; blockRS_idx < RStask_offsets[RStask + 1]; blockRS_idx++) {
            const auto& blockRS = blocksRS[blockRS_idx];
            for (const auto& pairRS : blockRS) {
                firstR = std::min(firstR, pairRS.first);
                firstS = std::min(firstS, pairRS.second);
            }
        }
        bool prn = firstS == 54;

        int nShellP = primary_->nshell_on_center(primary_->shell(firstP).ncenter());
        int nShellQ = primary_->nshell_on_center(primary_->shell(firstQ).ncenter());
        int nShellR = primary_->nshell_on_center(primary_->shell(firstR).ncenter());
        int nShellS = primary_->nshell_on_center(primary_->shell(firstS).ncenter());

        int totalPsize = 0;
        int totalQsize = 0;
        int totalRsize = 0;
        int totalSsize = 0;
        for (int P = firstP; P < firstP + nShellP; ++P) totalPsize += primary_->shell(P).nfunction();
        for (int Q = firstQ; Q < firstQ + nShellQ; ++Q) totalQsize += primary_->shell(Q).nfunction();
        for (int R = firstR; R < firstR + nShellR; ++R) totalRsize += primary_->shell(R).nfunction();
        for (int S = firstS; S < firstS + nShellS; ++S) totalSsize += primary_->shell(S).nfunction();
        const auto& firstPshell = primary_->shell(firstP);
        const auto& firstQshell = primary_->shell(firstQ);
        const auto& firstRshell = primary_->shell(firstR);
        const auto& firstSshell = primary_->shell(firstS);
        const auto firstPoff = firstPshell.function_index();
        const auto firstQoff = firstQshell.function_index();
        const auto firstRoff = firstRshell.function_index();
        const auto firstSoff = firstSshell.function_index();
        if (prn) std::cout << "DBG " << firstS << "  " << nShellS << "  " << std::endl;
        if (prn) for (int S = firstS; S < firstS + nShellS; ++S) std::cout << primary_->shell(S).nfunction() << "  " << primary_->shell(S).ncenter() << std::endl;
        std::set<std::pair<int, int>> PQshellpairs, RSshellpairs, PRshellpairs, PSshellpairs, QRshellpairs,
            QSshellpairs;
        std::cout << "GREPME" << std::endl;

        // loop over all the blocks of (P>=Q| belonging to the bra atom pair
        for (size_t blockPQ_idx = PQtask_offsets[PQtask]; blockPQ_idx < PQtask_offsets[PQtask + 1]; blockPQ_idx++) {
            const auto& blockPQ = blocksPQ[blockPQ_idx];
            // loop over all the blocks of |R>=S) belonging to the ket atom pair
            for (int blockRS_idx = RStask_offsets[RStask]; blockRS_idx < RStask_offsets[RStask + 1]; ++blockRS_idx) {
                const auto& blockRS = blocksRS[blockRS_idx];

                // use integral and density screening to figure out if this block is significant
                if (!ints[rank]->shell_block_significant(blockPQ_idx, blockRS_idx)) continue;

                // if (rank == 0) timer_on("JK: INTS");
                // compute the integrals and continue if none were computed
                ints[rank]->compute_shell_blocks(blockPQ_idx, blockRS_idx);
                // if (rank == 0) timer_off("JK: INTS");
                const double* block_start = buffers[0];

                // Loop over all of the P,Q,R,S shells within the blocks.  We have P>=Q, R>=S and PQ<=RS.
                for (const auto& pairPQ : blockPQ) {
                    int P = pairPQ.first;
                    int Q = pairPQ.second;
                    const auto& Pshell = primary_->shell(P);
                    const auto& Qshell = primary_->shell(Q);
                    const auto& Pam = Pshell.am();
                    const auto& Qam = Qshell.am();
                    const auto& Psize = Pshell.nfunction();
                    const auto& Qsize = Qshell.nfunction();
                    const auto& Poff = Pshell.function_index();
                    const auto& Qoff = Qshell.function_index();
                    const int relPoff = Poff - firstPoff;
                    const int relQoff = Qoff - firstQoff;

                    for (const auto& pairRS : blockRS) {
                        int R = pairRS.first;
                        int S = pairRS.second;
                        const auto& Rshell = primary_->shell(R);
                        const auto& Sshell = primary_->shell(S);
                        const auto& Ram = Rshell.am();
                        const auto& Sam = Sshell.am();
                        const auto& Rsize = Rshell.nfunction();
                        const auto& Ssize = Sshell.nfunction();
                        const auto& Roff = Rshell.function_index();
                        const auto& Soff = Sshell.function_index();
                        const int relRoff = Roff - firstRoff;
                        const int relSoff = Soff - firstSoff;

                        size_t block_size = Psize * Qsize * Rsize * Ssize;
                        // When there are chunks of shellpairs in RS, we need to make sure
                        // we filter out redundant combinations.  If we hop into the middle
                        // of an RS batch, we must make sure we ignore RS terms that correspond
                        // to terms lower than the current PQ, lest they be double counted.
                        // if (blockRS_idx == start && ((P > R) || (P == R && Q > S))) {
                        // if (((P > R) || (P == R && Q > S))) {
                        if (((P < R) || (P == R && Q < S))) {
                            block_start += block_size;
                            continue;
                        }
                        computed_shells++;
                        // Keep track of which shells have been processed here
                        std::cout << "INDS "  << P << "  "
                                              << Q << "  "
                                              << R << "  "
                                              << S << "  " << std::endl;
                        std::cout << "SIZES " << totalPsize << "  "
                                              << totalQsize << "  "
                                              << totalRsize << "  "
                                              << totalSsize << "  " << std::endl;
                        PQshellpairs.insert(std::make_pair(P, Q));
                        RSshellpairs.insert(std::make_pair(R, S));
                        PRshellpairs.insert(std::make_pair(P, R));
                        PSshellpairs.insert(std::make_pair(P, S));
                        QRshellpairs.insert(std::make_pair(Q, R));
                        QSshellpairs.insert(std::make_pair(Q, S));

                        // if (rank == 0) timer_on("JK: GEMV");
                        for (size_t ind = 0; ind < D.size(); ind++) {
                            double** Dp = D[ind]->pointer();
                            double** JKTp = JKT[rank][ind]->pointer();

                            double* J1p = JKTp[0L * max_task];
                            double* J2p = JKTp[1L * max_task];
                            double* K1p = JKTp[2L * max_task];
                            double* K2p = JKTp[3L * max_task];
                            double* K3p = JKTp[4L * max_task];
                            double* K4p = JKTp[5L * max_task];
                            double* K5p;
                            double* K6p;
                            double* K7p;
                            double* K8p;
                            if (!lr_symmetric_) {
                                K5p = JKTp[6L * max_task];
                                K6p = JKTp[7L * max_task];
                                K7p = JKTp[8L * max_task];
                                K8p = JKTp[9L * max_task];
                            }

                            double prefactor = 1.0;
                            if (P == Q) prefactor *= 0.5;
                            if (R == S) prefactor *= 0.5;
                            if (P == R && Q == S) prefactor *= 0.5;

                            if (!touched) {
                                std::cout << " ZEROING " << std::endl;
                                touched = true;
                                std::fill_n(JKTp[0L * max_task], totalPsize * totalQsize, 0.0);
                                std::fill_n(JKTp[1L * max_task], totalRsize * totalSsize, 0.0);
                                std::fill_n(JKTp[2L * max_task], totalPsize * totalRsize, 0.0);
                                std::fill_n(JKTp[3L * max_task], totalPsize * totalSsize, 0.0);
                                std::fill_n(JKTp[4L * max_task], totalQsize * totalRsize, 0.0);
                                std::fill_n(JKTp[5L * max_task], totalQsize * totalSsize, 0.0);
                                if (!lr_symmetric_) {
                                    std::fill_n(JKTp[6L * max_task], totalRsize * totalPsize, 0.0);
                                    std::fill_n(JKTp[7L * max_task], totalSsize * totalPsize, 0.0);
                                    std::fill_n(JKTp[8L * max_task], totalRsize * totalQsize, 0.0);
                                    std::fill_n(JKTp[9L * max_task], totalSsize * totalQsize, 0.0);
                                }
                            }
                            const double* int_ptr = block_start;
                            for (int p = 0; p < Psize; p++) {
                                const int Prel = p + relPoff;
                                const int Pabs = p + Poff;
                                for (int q = 0; q < Qsize; q++) {
                                    const int Qrel = q + relQoff;
                                    const int Qabs = q + Qoff;
                                    for (int r = 0; r < Rsize; r++) {
                                        const int Rrel = r + relRoff;
                                        const int Rabs = r + Roff;
                                        for (int s = 0; s < Ssize; s++) {
                                            const int Srel = s + relSoff;
                                            const int Sabs = s + Soff;
                                            double val = prefactor * (*int_ptr++);
                                            J1p[Prel * totalQsize + Qrel] += val * (Dp[Rabs][Sabs] + Dp[Sabs][Rabs]);
                                            J2p[Rrel * totalSsize + Srel] += val * (Dp[Pabs][Qabs] + Dp[Qabs][Pabs]);
                                            K1p[Prel * totalRsize + Rrel] += val * Dp[Qabs][Sabs];
                                            K2p[Prel * totalSsize + Srel] += val * Dp[Qabs][Rabs];
                                            K3p[Qrel * totalRsize + Rrel] += val * Dp[Pabs][Sabs];
                                            K4p[Qrel * totalSsize + Srel] += val * Dp[Pabs][Rabs];
                                            if (!lr_symmetric_) {
                                                K5p[Rrel * totalPsize + Prel] += val * Dp[Sabs][Qabs];
                                                K6p[Srel * totalPsize + Prel] += val * Dp[Rabs][Qabs];
                                                K7p[Rrel * totalQsize + Qrel] += val * Dp[Sabs][Pabs];
                                                K8p[Srel * totalQsize + Qrel] += val * Dp[Rabs][Pabs];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // if (rank == 0) timer_off("JK: GEMV");
                        block_start += block_size;
                    }  // pairRS
                }      // pairPQ
            }          // blockRS
        }              // blockPQ

        // => Accumulate atom blocks into full J and K matrices <= //
        if (!touched) continue;
        // if (rank == 0) timer_on("JK: Atomic");
        for (size_t ind = 0; ind < D.size(); ind++) {
            double** JKTp = JKT[rank][ind]->pointer();
            double** Jp = J[ind]->pointer();
            double** Kp = K[ind]->pointer();

            double* J1p = JKTp[0L * max_task];
            double* J2p = JKTp[1L * max_task];
            double* K1p = JKTp[2L * max_task];
            double* K2p = JKTp[3L * max_task];
            double* K3p = JKTp[4L * max_task];
            double* K4p = JKTp[5L * max_task];
            double* K5p;
            double* K6p;
            double* K7p;
            double* K8p;
            if (!lr_symmetric_) {
                K5p = JKTp[6L * max_task];
                K6p = JKTp[7L * max_task];
                K7p = JKTp[8L * max_task];
                K8p = JKTp[9L * max_task];
            }
            // > J_PQ < //
            for (const auto& PQ : PQshellpairs) {
                const int P = PQ.first;
                const int Q = PQ.second;
                const auto& Pshell = primary_->shell(P);
                const int Psize = Pshell.nfunction();
                const int Poff = Pshell.function_index();
                const int relPoff = Poff - firstPoff;
                const auto& Qshell = primary_->shell(Q);
                const int Qsize = Qshell.nfunction();
                const int Qoff = Qshell.function_index();
                const int relQoff = Qoff - firstQoff;
                for (int p = 0; p < Psize; p++) {
                    const int pRel = p + relPoff;
                    const int pAbs = p + Poff;
                    for (int q = 0; q < Qsize; q++) {
                        const int qRel = q + relQoff;
                        const int qAbs = q + Qoff;
#pragma omp atomic
                        Jp[pAbs][qAbs] += J1p[pRel * totalQsize + qRel];
                    }
                }
            }

            // > J_RS < //

            for (const auto& RS : RSshellpairs) {
                const int R = RS.first;
                const int S = RS.second;
                const auto& Rshell = primary_->shell(R);
                const int Rsize = Rshell.nfunction();
                const int Roff = Rshell.function_index();
                const int relRoff = Roff - firstRoff;
                const auto& Sshell = primary_->shell(S);
                const int Ssize = Sshell.nfunction();
                const int Soff = Sshell.function_index();
                const int relSoff = Soff - firstSoff;
                for (int r = 0; r < Rsize; r++) {
                    const int rRel = r + relRoff;
                    const int rAbs = r + Roff;
                    for (int s = 0; s < Ssize; s++) {
                        const int sRel = s + relSoff;
                        const int sAbs = s + Soff;
#pragma omp atomic
                        Jp[rAbs][sAbs] += J2p[rRel * totalSsize + sRel];
                    }
                }
            }

            // > K_PR < //

            for (const auto& PR : PRshellpairs) {
                const int P = PR.first;
                const int R = PR.second;
                const auto& Pshell = primary_->shell(P);
                const int Psize = Pshell.nfunction();
                const int Poff = Pshell.function_index();
                const int relPoff = Poff - firstPoff;
                const auto& Rshell = primary_->shell(R);
                const int Rsize = Rshell.nfunction();
                const int Roff = Rshell.function_index();
                const int relRoff = Roff - firstRoff;
                for (int p = 0; p < Psize; p++) {
                    const int pRel = p + relPoff;
                    const int pAbs = p + Poff;
                    for (int r = 0; r < Rsize; r++) {
                        const int rRel = r + relRoff;
                        const int rAbs = r + Roff;
#pragma omp atomic
                        Kp[pAbs][rAbs] += K1p[pRel * totalRsize + rRel];
                        if (!lr_symmetric_) {
#pragma omp atomic
                            Kp[rAbs][pAbs] += K5p[rRel * totalPsize + pRel];
                        }
                    }
                }
            }

            // > K_PS < //

            for (const auto& PS : PSshellpairs) {
                const int P = PS.first;
                const int S = PS.second;
                const auto& Pshell = primary_->shell(P);
                const int Psize = Pshell.nfunction();
                const int Poff = Pshell.function_index();
                const int relPoff = Poff - firstPoff;
                const auto& Sshell = primary_->shell(S);
                const int Ssize = Sshell.nfunction();
                const int Soff = Sshell.function_index();
                const int relSoff = Soff - firstSoff;
                for (int p = 0; p < Psize; p++) {
                    const int pRel = p + relPoff;
                    const int pAbs = p + Poff;
                    for (int s = 0; s < Ssize; s++) {
                        const int sRel = s + relSoff;
                        const int sAbs = s + Soff;
#pragma omp atomic
                        Kp[pAbs][sAbs] += K2p[pRel * totalSsize + sRel];
                        if (!lr_symmetric_) {
#pragma omp atomic
                            Kp[sAbs][pAbs] += K6p[sRel * totalPsize + pRel];
                        }
                    }
                }
            }

            // > K_QR < //

            for (const auto& QR : QRshellpairs) {
                const int Q = QR.first;
                const int R = QR.second;
                const auto& Qshell = primary_->shell(Q);
                const int Qsize = Qshell.nfunction();
                const int Qoff = Qshell.function_index();
                const int relQoff = Qoff - firstQoff;
                const auto& Rshell = primary_->shell(R);
                const int Rsize = Rshell.nfunction();
                const int Roff = Rshell.function_index();
                const int relRoff = Roff - firstRoff;
                for (int q = 0; q < Qsize; q++) {
                    const int qRel = q + relQoff;
                    const int qAbs = q + Qoff;
                    for (int r = 0; r < Rsize; r++) {
                        const int rRel = r + relRoff;
                        const int rAbs = r + Roff;
#pragma omp atomic
                        Kp[qAbs][rAbs] += K3p[qRel * totalRsize + rRel];
                        if (!lr_symmetric_) {
#pragma omp atomic
                            Kp[rAbs][qAbs] += K7p[rRel * totalQsize + qRel];
                        }
                    }
                }
            }
            // > K_QS < //

            for (const auto& QS : QSshellpairs) {
                const int Q = QS.first;
                const int S = QS.second;
                const auto& Qshell = primary_->shell(Q);
                const int Qsize = Qshell.nfunction();
                const int Qoff = Qshell.function_index();
                const int relQoff = Qoff - firstQoff;
                const auto& Sshell = primary_->shell(S);
                const int Ssize = Sshell.nfunction();
                const int Soff = Sshell.function_index();
                const int relSoff = Soff - firstSoff;
                for (int q = 0; q < Qsize; q++) {
                    const int qRel = q + relQoff;
                    const int qAbs = q + Qoff;
                    for (int s = 0; s < Ssize; s++) {
                        const int sRel = s + relSoff;
                        const int sAbs = s + Soff;
#pragma omp atomic
                        Kp[qAbs][sAbs] += K4p[qRel * totalSsize + sRel];
                        if (!lr_symmetric_) {
#pragma omp atomic
                            Kp[sAbs][qAbs] += K8p[sRel * totalQsize + qRel];
                        }
                    }
                }
            }
        }
        // if (rank == 0) timer_off("JK: Atomic");
    }  // PQRS task
    for (size_t ind = 0; ind < D.size(); ind++) {
        J[ind]->scale(2.0);
        J[ind]->hermitivitize();
        if (lr_symmetric_) {
            K[ind]->scale(2.0);
            K[ind]->hermitivitize();
        }
    }
}

#if 0
DirectJK::DirectJK(std::shared_ptr<BasisSet> primary) :
   JK(primary)
{
    common_init();
}
DirectJK::~DirectJK()
{
}
void DirectJK::common_init()
{
}
void DirectJK::print_header() const
{
    if (print_) {
        outfile->Printf( "  ==> DirectJK: Integral-Direct J/K Matrices <==\n\n");

        outfile->Printf( "    J tasked:          %11s\n", (do_J_ ? "Yes" : "No"));
        outfile->Printf( "    K tasked:          %11s\n", (do_K_ ? "Yes" : "No"));
        outfile->Printf( "    wK tasked:         %11s\n", (do_wK_ ? "Yes" : "No"));
        if (do_wK_)
            outfile->Printf( "    Omega:             %11.3E\n", omega_);
        outfile->Printf( "    OpenMP threads:    %11d\n", omp_nthread_);
        outfile->Printf( "    Memory [MiB]:      %11ld\n", (memory_ *8L) / (1024L * 1024L));
        outfile->Printf( "    Schwarz Cutoff:    %11.0E\n\n", cutoff_);
    }
}
void DirectJK::preiterations()
{
    sieve_ = std::make_shared<ERISieve>(primary_, cutoff_);
    factory_= std::make_shared<IntegralFactory>(primary_,primary_,primary_,primary_);
    eri_.clear();
    for (int thread = 0; thread < omp_nthread_; thread++) {
        eri_.push_back(std::shared_ptr<TwoBodyAOInt>(factory_->erd_eri()));
    }
}
void DirectJK::compute_JK()
{
    // Correctness always counts
    const double* buffer = eri_[0]->buffer();
    for (int M = 0; M < primary_->nshell(); ++M) {
    for (int N = 0; N < primary_->nshell(); ++N) {
    for (int R = 0; R < primary_->nshell(); ++R) {
    for (int S = 0; S < primary_->nshell(); ++S) {

        if(eri_[0]->compute_shell(M,N,R,S) == 0)
            continue; // No integrals were computed here

        int nM = primary_->shell(M).nfunction();
        int nN = primary_->shell(N).nfunction();
        int nR = primary_->shell(R).nfunction();
        int nS = primary_->shell(S).nfunction();

        int sM = primary_->shell(M).function_index();
        int sN = primary_->shell(N).function_index();
        int sR = primary_->shell(R).function_index();
        int sS = primary_->shell(S).function_index();

        for (int oM = 0, index = 0; oM < nM; oM++) {
        for (int oN = 0; oN < nN; oN++) {
        for (int oR = 0; oR < nR; oR++) {
        for (int oS = 0; oS < nS; oS++, index++) {

            double val = buffer[index];

            int m = oM + sM;
            int n = oN + sN;
            int r = oR + sR;
            int s = oS + sS;

            if (do_J_) {
                for (int N = 0; N < J_ao_.size(); N++) {
                    J_ao_[N]->add(0,m,n, D_ao_[N]->get(0,r,s)*val);
                }
            }

            if (do_K_) {
                for (int N = 0; N < K_ao_.size(); N++) {
                    K_ao_[N]->add(0,m,s, D_ao_[N]->get(0,n,r)*val);
                }
            }

        }}}}

    }}}}

    // Faster version, not finished
    /**
    sieve_->set_sieve(cutoff_);
    const std::vector<std::pair<int,int> >& shell_pairs = sieve_->shell_pairs();
    size_t nMN = shell_pairs.size();
    size_t nMNRS = nMN * nMN;
    int nthread = eri_.size();

    #pragma omp parallel for schedule(dynamic,30) num_threads(nthread)
    for (size_t index = 0L; index < nMNRS; ++index) {

        int thread = 0;
        #ifdef _OPENMP
            thread = omp_get_thread_num();
        #endif

        const double* buffer = eri_[thread]->buffer();

        size_t MN = index / nMN;
        size_t RS = index % nMN;
        if (MN < RS) continue;

        int M = shell_pairs[MN].first;
        int N = shell_pairs[MN].second;
        int R = shell_pairs[RS].first;
        int S = shell_pairs[RS].second;

        eri_[thread]->compute_shell(M,N,R,S);

        int nM = primary_->shell(M)->nfunction();
        int nN = primary_->shell(N)->nfunction();
        int nR = primary_->shell(R)->nfunction();
        int nS = primary_->shell(S)->nfunction();

        int sM = primary_->shell(M)->function_index();
        int sN = primary_->shell(N)->function_index();
        int sR = primary_->shell(R)->function_index();
        int sS = primary_->shell(S)->function_index();

        for (int oM = 0, index = 0; oM < nM; oM++) {
        for (int oN = 0; oN < nN; oN++) {
        for (int oR = 0; oR < nR; oR++) {
        for (int oS = 0; oS < nS; oS++, index++) {

            int m = oM + sM;
            int n = oN + sN;
            int r = oR + sR;
            int s = oS + sS;

            if ((n > m) || (s > r) || ((r*(r+1) >> 1) + s > (m*(m+1) >> 1) + n)) continue;

            double val = buffer[index];

            if (do_J_) {
                for (int N = 0; N < J_ao_.size(); N++) {
                    double** Dp = D_ao_[N]->pointer();
                    double** Jp = J_ao_[N]->pointer();

                    // I've given you all the unique ones
                    // Make sure to use #pragma omp atomic
                    // TODO
                }
            }

            if (do_K_) {
                for (int N = 0; N < K_ao_.size(); N++) {
                    double** Dp = D_ao_[N]->pointer();
                    double** Kp = J_ao_[N]->pointer();

                    // I've given you all the unique ones
                    // Make sure to use #pragma omp atomic
                    // TODO
                }
            }

        }}}}

    }
    **/
}

#endif
}  // namespace psi
